# 锁
读锁是共享的或者是相互不阻塞的.多个用户
## 读写锁
共享锁: 读锁
排他锁: 写锁
## 锁的粒度
### 表锁
开销最小的策略,写锁会阻塞所有其他用户对表的操作[读|写],  
在特定场景中表锁：可能有良好的性能. (READ,LOCAL表锁) 支持某些类型的并发写操作.  
**写锁** 比读锁有更高的优先级,写锁可能会被插入到读锁队列的最前面.  
`ALTER TABLE`之类的会使用表锁.
### 行级锁
可以最大程度的支持并发处理(也会带来最大的锁的开销). `行级锁只在存储引擎实现`
#### MVCC
### 事务
#### ACID 
* A -> 原子性  
* C -> 一致性  
* I -> 隔离性  
* D -> 持久性 
1. 原子性:  
  一个事务必须视为一个不可分割的最小工作单元,整个事务要么全部成功，要么全部失败。
2. 一致性:
  数据库总是从一个一致性的状态转换到另外一个一致性的状态.
3. 隔离性:
  一个事务所作的修改在最终提交以前，对其他的事务是不可见的. eg: 一个事务减少金额200 另一个事务增加100金额 同时提交(队列，交易金额对比(补偿))
4. 持久性:
  一旦事务提交，所做的修改会永久保存到数据库中。即使系统崩溃，修改的数据也不会丢失.

### 死锁
两个或者多个事务在同一资源上相互占用。  
InnoDB: 将持有最小行级排他锁的事务进行回滚. 