# Array
## 遍历效率

```
Array length:  10 
 { sum: 0.00014542220000000175,
  sumCache: 0.00019776630000000104,
  sumForIn: 0.0005868104000000051,
  sumForOf: 0.000287438999999998,
  sumForEach: 0.0004855658000000118,
  sumReduce: 0.00027416709999999593 }
Array length:  100 
 { sum: 0.00017366710000001263,
  sumCache: 0.00015662109999999737,
  sumForIn: 0.0035537822000000128,
  sumForOf: 0.0001979232000000115,
  sumForEach: 0.0012123821000000034,
  sumReduce: 0.0011420654999999816 }
Array length:  1000 
 { sum: 0.00113254919999992,
  sumCache: 0.0012095744000000276,
  sumForIn: 0.03228956200000003,
  sumForOf: 0.0013800691999999604,
  sumForEach: 0.01137803330000002,
  sumReduce: 0.010833424799999925 }
Array length:  10000 
 { sum: 0.010557092000000153,
  sumCache: 0.010501515000000163,
  sumForIn: 0.30997526749999976,
  sumForOf: 0.013016700399999996,
  sumForEach: 0.11252283860000044,
  sumReduce: 0.10940369320000021 }
	Array length:  100000 
 { sum: 0.10628562379999573,
  sumCache: 0.10477402829999917,
  sumForIn: 10.57826515470005,
  sumForOf: 0.13491074159999988,
  sumForEach: 1.3143189285000008,
  sumReduce: 1.243294164999998 }
Array length:  1000000 
 { sum: 1.2904440202999998,
  sumCache: 1.6183457168000013,
  sumForIn: 108.80697046710048,
  sumForOf: 1.5166219548000048,
  sumForEach: 22.438207055400035,
  sumReduce: 16.364774765200096 }
```
可以看出当数据量大于`1000`的时候 使用`foreach`基本没有什么优势了.  
而`Reduce`的方法是在数据量大于`100000`的时候败下阵来  
使用带array.length缓存的时候并没有什么优势.猜测是优化了for循环.  
当然这个测试并没有考虑到内存的占用率等

还是老老实实用`for`吧... `Reduce`　也是一种方法[在这里]